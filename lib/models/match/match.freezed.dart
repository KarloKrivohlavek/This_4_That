// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'match.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

MatchedItems _$MatchedItemsFromJson(Map<String, dynamic> json) {
  return _MatchedItems.fromJson(json);
}

/// @nodoc
mixin _$MatchedItems {
  @JsonKey(name: 'item1_name')
  String get item1Name => throw _privateConstructorUsedError;
  @JsonKey(name: 'item2_name')
  String get item2Name => throw _privateConstructorUsedError;
  @JsonKey(name: 'user1_username')
  String get user1Username => throw _privateConstructorUsedError;
  @JsonKey(name: 'user2_username')
  String get user2Username => throw _privateConstructorUsedError;
  @JsonKey(name: 'item1_pictureURL')
  String get item1PictureURL => throw _privateConstructorUsedError;
  @JsonKey(name: 'item2_pictureURL')
  String get item2PictureURL => throw _privateConstructorUsedError;
  @JsonKey(name: 'user1_ID')
  String get user1ID => throw _privateConstructorUsedError;
  @JsonKey(name: 'user2_ID')
  String get user2ID => throw _privateConstructorUsedError;
  @JsonKey(name: 'item1_ID')
  String get item1ID => throw _privateConstructorUsedError;
  @JsonKey(name: 'item2_ID')
  String get item2ID => throw _privateConstructorUsedError;
  @JsonKey(name: 'match_ID')
  String get matchID => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MatchedItemsCopyWith<MatchedItems> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MatchedItemsCopyWith<$Res> {
  factory $MatchedItemsCopyWith(
          MatchedItems value, $Res Function(MatchedItems) then) =
      _$MatchedItemsCopyWithImpl<$Res, MatchedItems>;
  @useResult
  $Res call(
      {@JsonKey(name: 'item1_name') String item1Name,
      @JsonKey(name: 'item2_name') String item2Name,
      @JsonKey(name: 'user1_username') String user1Username,
      @JsonKey(name: 'user2_username') String user2Username,
      @JsonKey(name: 'item1_pictureURL') String item1PictureURL,
      @JsonKey(name: 'item2_pictureURL') String item2PictureURL,
      @JsonKey(name: 'user1_ID') String user1ID,
      @JsonKey(name: 'user2_ID') String user2ID,
      @JsonKey(name: 'item1_ID') String item1ID,
      @JsonKey(name: 'item2_ID') String item2ID,
      @JsonKey(name: 'match_ID') String matchID});
}

/// @nodoc
class _$MatchedItemsCopyWithImpl<$Res, $Val extends MatchedItems>
    implements $MatchedItemsCopyWith<$Res> {
  _$MatchedItemsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? item1Name = null,
    Object? item2Name = null,
    Object? user1Username = null,
    Object? user2Username = null,
    Object? item1PictureURL = null,
    Object? item2PictureURL = null,
    Object? user1ID = null,
    Object? user2ID = null,
    Object? item1ID = null,
    Object? item2ID = null,
    Object? matchID = null,
  }) {
    return _then(_value.copyWith(
      item1Name: null == item1Name
          ? _value.item1Name
          : item1Name // ignore: cast_nullable_to_non_nullable
              as String,
      item2Name: null == item2Name
          ? _value.item2Name
          : item2Name // ignore: cast_nullable_to_non_nullable
              as String,
      user1Username: null == user1Username
          ? _value.user1Username
          : user1Username // ignore: cast_nullable_to_non_nullable
              as String,
      user2Username: null == user2Username
          ? _value.user2Username
          : user2Username // ignore: cast_nullable_to_non_nullable
              as String,
      item1PictureURL: null == item1PictureURL
          ? _value.item1PictureURL
          : item1PictureURL // ignore: cast_nullable_to_non_nullable
              as String,
      item2PictureURL: null == item2PictureURL
          ? _value.item2PictureURL
          : item2PictureURL // ignore: cast_nullable_to_non_nullable
              as String,
      user1ID: null == user1ID
          ? _value.user1ID
          : user1ID // ignore: cast_nullable_to_non_nullable
              as String,
      user2ID: null == user2ID
          ? _value.user2ID
          : user2ID // ignore: cast_nullable_to_non_nullable
              as String,
      item1ID: null == item1ID
          ? _value.item1ID
          : item1ID // ignore: cast_nullable_to_non_nullable
              as String,
      item2ID: null == item2ID
          ? _value.item2ID
          : item2ID // ignore: cast_nullable_to_non_nullable
              as String,
      matchID: null == matchID
          ? _value.matchID
          : matchID // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MatchedItemsCopyWith<$Res>
    implements $MatchedItemsCopyWith<$Res> {
  factory _$$_MatchedItemsCopyWith(
          _$_MatchedItems value, $Res Function(_$_MatchedItems) then) =
      __$$_MatchedItemsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'item1_name') String item1Name,
      @JsonKey(name: 'item2_name') String item2Name,
      @JsonKey(name: 'user1_username') String user1Username,
      @JsonKey(name: 'user2_username') String user2Username,
      @JsonKey(name: 'item1_pictureURL') String item1PictureURL,
      @JsonKey(name: 'item2_pictureURL') String item2PictureURL,
      @JsonKey(name: 'user1_ID') String user1ID,
      @JsonKey(name: 'user2_ID') String user2ID,
      @JsonKey(name: 'item1_ID') String item1ID,
      @JsonKey(name: 'item2_ID') String item2ID,
      @JsonKey(name: 'match_ID') String matchID});
}

/// @nodoc
class __$$_MatchedItemsCopyWithImpl<$Res>
    extends _$MatchedItemsCopyWithImpl<$Res, _$_MatchedItems>
    implements _$$_MatchedItemsCopyWith<$Res> {
  __$$_MatchedItemsCopyWithImpl(
      _$_MatchedItems _value, $Res Function(_$_MatchedItems) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? item1Name = null,
    Object? item2Name = null,
    Object? user1Username = null,
    Object? user2Username = null,
    Object? item1PictureURL = null,
    Object? item2PictureURL = null,
    Object? user1ID = null,
    Object? user2ID = null,
    Object? item1ID = null,
    Object? item2ID = null,
    Object? matchID = null,
  }) {
    return _then(_$_MatchedItems(
      item1Name: null == item1Name
          ? _value.item1Name
          : item1Name // ignore: cast_nullable_to_non_nullable
              as String,
      item2Name: null == item2Name
          ? _value.item2Name
          : item2Name // ignore: cast_nullable_to_non_nullable
              as String,
      user1Username: null == user1Username
          ? _value.user1Username
          : user1Username // ignore: cast_nullable_to_non_nullable
              as String,
      user2Username: null == user2Username
          ? _value.user2Username
          : user2Username // ignore: cast_nullable_to_non_nullable
              as String,
      item1PictureURL: null == item1PictureURL
          ? _value.item1PictureURL
          : item1PictureURL // ignore: cast_nullable_to_non_nullable
              as String,
      item2PictureURL: null == item2PictureURL
          ? _value.item2PictureURL
          : item2PictureURL // ignore: cast_nullable_to_non_nullable
              as String,
      user1ID: null == user1ID
          ? _value.user1ID
          : user1ID // ignore: cast_nullable_to_non_nullable
              as String,
      user2ID: null == user2ID
          ? _value.user2ID
          : user2ID // ignore: cast_nullable_to_non_nullable
              as String,
      item1ID: null == item1ID
          ? _value.item1ID
          : item1ID // ignore: cast_nullable_to_non_nullable
              as String,
      item2ID: null == item2ID
          ? _value.item2ID
          : item2ID // ignore: cast_nullable_to_non_nullable
              as String,
      matchID: null == matchID
          ? _value.matchID
          : matchID // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MatchedItems with DiagnosticableTreeMixin implements _MatchedItems {
  _$_MatchedItems(
      {@JsonKey(name: 'item1_name') required this.item1Name,
      @JsonKey(name: 'item2_name') required this.item2Name,
      @JsonKey(name: 'user1_username') required this.user1Username,
      @JsonKey(name: 'user2_username') required this.user2Username,
      @JsonKey(name: 'item1_pictureURL') required this.item1PictureURL,
      @JsonKey(name: 'item2_pictureURL') required this.item2PictureURL,
      @JsonKey(name: 'user1_ID') required this.user1ID,
      @JsonKey(name: 'user2_ID') required this.user2ID,
      @JsonKey(name: 'item1_ID') required this.item1ID,
      @JsonKey(name: 'item2_ID') required this.item2ID,
      @JsonKey(name: 'match_ID') required this.matchID});

  factory _$_MatchedItems.fromJson(Map<String, dynamic> json) =>
      _$$_MatchedItemsFromJson(json);

  @override
  @JsonKey(name: 'item1_name')
  final String item1Name;
  @override
  @JsonKey(name: 'item2_name')
  final String item2Name;
  @override
  @JsonKey(name: 'user1_username')
  final String user1Username;
  @override
  @JsonKey(name: 'user2_username')
  final String user2Username;
  @override
  @JsonKey(name: 'item1_pictureURL')
  final String item1PictureURL;
  @override
  @JsonKey(name: 'item2_pictureURL')
  final String item2PictureURL;
  @override
  @JsonKey(name: 'user1_ID')
  final String user1ID;
  @override
  @JsonKey(name: 'user2_ID')
  final String user2ID;
  @override
  @JsonKey(name: 'item1_ID')
  final String item1ID;
  @override
  @JsonKey(name: 'item2_ID')
  final String item2ID;
  @override
  @JsonKey(name: 'match_ID')
  final String matchID;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MatchedItems(item1Name: $item1Name, item2Name: $item2Name, user1Username: $user1Username, user2Username: $user2Username, item1PictureURL: $item1PictureURL, item2PictureURL: $item2PictureURL, user1ID: $user1ID, user2ID: $user2ID, item1ID: $item1ID, item2ID: $item2ID, matchID: $matchID)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MatchedItems'))
      ..add(DiagnosticsProperty('item1Name', item1Name))
      ..add(DiagnosticsProperty('item2Name', item2Name))
      ..add(DiagnosticsProperty('user1Username', user1Username))
      ..add(DiagnosticsProperty('user2Username', user2Username))
      ..add(DiagnosticsProperty('item1PictureURL', item1PictureURL))
      ..add(DiagnosticsProperty('item2PictureURL', item2PictureURL))
      ..add(DiagnosticsProperty('user1ID', user1ID))
      ..add(DiagnosticsProperty('user2ID', user2ID))
      ..add(DiagnosticsProperty('item1ID', item1ID))
      ..add(DiagnosticsProperty('item2ID', item2ID))
      ..add(DiagnosticsProperty('matchID', matchID));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MatchedItems &&
            (identical(other.item1Name, item1Name) ||
                other.item1Name == item1Name) &&
            (identical(other.item2Name, item2Name) ||
                other.item2Name == item2Name) &&
            (identical(other.user1Username, user1Username) ||
                other.user1Username == user1Username) &&
            (identical(other.user2Username, user2Username) ||
                other.user2Username == user2Username) &&
            (identical(other.item1PictureURL, item1PictureURL) ||
                other.item1PictureURL == item1PictureURL) &&
            (identical(other.item2PictureURL, item2PictureURL) ||
                other.item2PictureURL == item2PictureURL) &&
            (identical(other.user1ID, user1ID) || other.user1ID == user1ID) &&
            (identical(other.user2ID, user2ID) || other.user2ID == user2ID) &&
            (identical(other.item1ID, item1ID) || other.item1ID == item1ID) &&
            (identical(other.item2ID, item2ID) || other.item2ID == item2ID) &&
            (identical(other.matchID, matchID) || other.matchID == matchID));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      item1Name,
      item2Name,
      user1Username,
      user2Username,
      item1PictureURL,
      item2PictureURL,
      user1ID,
      user2ID,
      item1ID,
      item2ID,
      matchID);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MatchedItemsCopyWith<_$_MatchedItems> get copyWith =>
      __$$_MatchedItemsCopyWithImpl<_$_MatchedItems>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MatchedItemsToJson(
      this,
    );
  }
}

abstract class _MatchedItems implements MatchedItems {
  factory _MatchedItems(
      {@JsonKey(name: 'item1_name')
          required final String item1Name,
      @JsonKey(name: 'item2_name')
          required final String item2Name,
      @JsonKey(name: 'user1_username')
          required final String user1Username,
      @JsonKey(name: 'user2_username')
          required final String user2Username,
      @JsonKey(name: 'item1_pictureURL')
          required final String item1PictureURL,
      @JsonKey(name: 'item2_pictureURL')
          required final String item2PictureURL,
      @JsonKey(name: 'user1_ID')
          required final String user1ID,
      @JsonKey(name: 'user2_ID')
          required final String user2ID,
      @JsonKey(name: 'item1_ID')
          required final String item1ID,
      @JsonKey(name: 'item2_ID')
          required final String item2ID,
      @JsonKey(name: 'match_ID')
          required final String matchID}) = _$_MatchedItems;

  factory _MatchedItems.fromJson(Map<String, dynamic> json) =
      _$_MatchedItems.fromJson;

  @override
  @JsonKey(name: 'item1_name')
  String get item1Name;
  @override
  @JsonKey(name: 'item2_name')
  String get item2Name;
  @override
  @JsonKey(name: 'user1_username')
  String get user1Username;
  @override
  @JsonKey(name: 'user2_username')
  String get user2Username;
  @override
  @JsonKey(name: 'item1_pictureURL')
  String get item1PictureURL;
  @override
  @JsonKey(name: 'item2_pictureURL')
  String get item2PictureURL;
  @override
  @JsonKey(name: 'user1_ID')
  String get user1ID;
  @override
  @JsonKey(name: 'user2_ID')
  String get user2ID;
  @override
  @JsonKey(name: 'item1_ID')
  String get item1ID;
  @override
  @JsonKey(name: 'item2_ID')
  String get item2ID;
  @override
  @JsonKey(name: 'match_ID')
  String get matchID;
  @override
  @JsonKey(ignore: true)
  _$$_MatchedItemsCopyWith<_$_MatchedItems> get copyWith =>
      throw _privateConstructorUsedError;
}
